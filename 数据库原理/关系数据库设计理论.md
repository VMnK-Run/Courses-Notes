<center><h3>关系数据库设计理论</h3></center>

---

> 核心问题：如何设计一个好的数据库？

#### 1. 函数依赖

##### 1.1 函数依赖的定义

+ 函数依赖 Functional Dependencies Fd;
  + 作用在关系上的约束
  + 键的概念的泛化
+ 定义
  + $A_1$ ~ $A_n$上一致，则$B_1$ ~ $B_n$ 也一致
  + 形式记法：$A1A2...An → B1B2...Bn$
+ 关系R满足函数依赖F:
  + R每个实例都能使一个给定的FD为真，则R满足（satisfy）函数依赖f
  + 在R上声明一个约束，不是实例
+ 关系的键
  + 最小的可以决定其他所有属性的集合
  + 主键：
    + 一个关系会有多个键，指定其中一个为主键
+ 超键：
  + 包含键的属性的集合，键的超集
  + 不一定使是最小的

#### 2 函数依赖规则

##### 2.1 规则：

- 等价 Equivalent：
  - 如果满足 FD S 的关系实例的集合和满足 FD T 的关系实例的集合相同，则 S 和 T 等价
- 推断 Follows：
  - 如果满足 FD T 的所有关系实例也满足 FD S，则 T 可以推断出 S（S follows from T）
- 分解规则 Splitting rule：
  - $A1A2...An → B1B2...Bm$ 等价于 $A1A2...An → Bi，i = 1,2,...,m$
- 组合规则 Combining rule：
  - $A1A2...An → Bi，i = 1,2,...,m$ 等价于 $A1A2...An → B1B2...Bm$

##### 2.2 平凡函数依赖：

+ 平凡 trivial：
  + 关系上的一个约束对所有关系实例都成立，且与其他约束无关（重点在与其他约束无关）
+ 平凡函数依赖 trivial's FDs:
  + $A_1A_2...A_n → B_1B_2...B_m (\{B_1,B_2,...,B_m\}\subseteq\{A_1,A_2,...,A_m\})$
  + 每个关系都存在平凡FD：两个元组在属性A1A2...An上取值相同，则他们在这n个属性上任一个子集取值都相同
+ 平凡依赖规则：
  + 若$A1A2...An → B1B2...Bm，则A1A2...An → C1C2...Ck$（C 是 B 的子集而不是 A 的子集）
  + 去掉了平凡依赖，去掉了显而易见的部分

##### 2.3 计算属性的闭包

+ 闭包 closure：
  + $\{A_1,A_2,...,A_n\} 的闭包记作 \{A_1,A_2,...,A_n\}^+$
  + 属性集连同它能函数决定的集合
  + 其实就是做出了闭环，不能再推断出其他依赖
+ A能函数决定B，当且仅当B在A的闭包中
+ 闭包算法
  1. 分解FD，使每个FD右边只有一个属性
  2. 设X为闭包，初始化X为$\{A_1,A_2,...A_n\}$
  3. 根据FD反复向X中添加属性
  4. 等到不能增加时，X为闭包
+ 传递规则
  + $A1A2...An → B1B2...Bm$和$B1B2...Bm → C1C2...Ck$都成立，则$A1A2...An →C1C2...Ck$
+ 超键的闭包包含所有属性
+ 移除一个属性的主键闭包不能包含所有属性

##### 2.4 函数依赖的闭包集合

需要选择哪一个FD集合来表示完全FD

+ 基本集 basis

  + 任何和S等价的FD集合都是S的基本集

+ 最小化基本集minimal basis：

  1. 最小基本集中所有 FD 右侧只有一个属性
  2. 从最小基本集中删除任何一个 FD，它不再是基本集
  3. 删除其中一个 FD 左侧的一个或多个属性，它不再是基本集

+ 公理

  + 自反律 reflexivity ：平凡FD
  + 增广律 augmentation：$A→B$,则$AC→BC$

  + 传递律 transitivity

##### 2.5 投影函数依赖

+ 其实就是只包含某一个属性集的依赖集
+ 计算方法
  1. 计算属性集每一个子集的闭包（可以有简化过程）
  2. 每算出一个闭包，添加新的函数依赖规则
  3. 将得到到依赖集做最小基本集

#### 3 关系数据库模式设计

不仔细选择模式会带来冗余和异常

冗余：在多个元组中重复

更新异常

删除异常

##### 3.1 分解 decomposition

+ 用分解消除异常
+ 给定关系 R(A1,A2,...,An)，分解为 S(B1,B2,...Bm) 和 T(C1,C2,...,Ck) 满足：
  1. {A1,A2,...An} = {B1,B2,...,Bm} $\cup$ {C1,C2,...,Ck}
  2. $S = \pi_{B_1,B_2,...,B_m}(R)$
  3. $T = \pi_{C_1,C_2,...,C_k}(R)$

##### 3.2 BC范式

BC范式是针对于某一关系来说的，其实也就是表上都有哪些属性

Boyce-Codd Normal Form，BCNF：

+ 每个非平凡FD的左侧都包含键

+ 算法：已知关系R和上面的函数依赖集S
  1. 找到违反BCNF的非平凡FD A1A2...An → B1B2...Bm，计算属性集A的闭包，选择$A^+$ 作为一个关系模式R1
  2. A和剩余的属性作为另一个关系模式R2
  3. 分别计算R1和R2上的投影函数依赖，得到两个FD集F1和F2
  4. 递归的计算R1和R2

##### 3.3 分解

分解前包含异常，分解后不包含异常

好的分解三条性质：

+ 消除异常
+ 信息可恢复：从分解的元组中恢复原始关系
+ 依赖保持：FD的投影在分解后关系上成立，确保分解后的关系连接重构后获取的原始关系依然满足原FD

##### 3.4 分解中恢复信息

能保证通过连接分解的关系重构原关系R？

+ 无损连接 lossless join
  + R 分解后的关系可以重构得到 R，称该分解含有无损连接
+ 依照上述 BCNF 分解算法分解关系，则可以通过自然连接得到初始关系：
  - 属性集 X、Y、Z
  - 如果 R 有 FD Y → Z，且 R 的属性集为 $X\cup Y\cup Z$
  - 则 $R = \pi_{X\cup Y}(R)\Join\pi_{Y\cup Z}(R)$

##### 3.5 无损连接的chase检验

三条重要性质

1. 自然连接满足交换律结合律

2. R中元组都在链接后的元组中
3. 要进行成员关系测试，验证分解包含无损连接

+ chase检验：
  1. 逐行表示分解的属性集，每一行中设置几个不带下表的属性值，表明这些属性在分解出的属性集中
  2. 利用FD修改属性值，优先改为没有下标的
  3. 如果得到无下标的元组，则是无损连接

##### 3.6 保持依赖

某些情况下，分解为BCNF后无法同时拥有无损连接和保持依赖

##### 3.7 第三范式

Third Normal Form 3NF:

放松了对BCNF的要求

满足：

+ 对于每个非平凡FD，要么左边是超键，要么右边是主属性

主属性（prime）：键的成员

###### 3.7.1 3NF综合算法

分解R满足：

- 分解得到的关系都属于 3NF
- 分解包含无损连接
- 分解保持依赖

算法：（已知关系R和函数依赖集F）

1. 找到F的一个最小基本集G
2. 对于G中每个FD X → A，将XA作为分解出的某个关系的模式（保持依赖）
3. 如果上述模式均不包含 R 的超键，则增加一个关系，其模式为 R 的任何一个键（超键无损）

##### 3.8 多值依赖 MVD

######  3.8.1Multivalued Dependency

+ 两个属性或属性集合之间的相互独立的断言
+ 广义函数依赖

- 对于 R 中每个在所有 A 属性上一致的元组对 t 和 u，能在 R 中找到满足下列条件的元组 v：
  1. 在 A 属性上的取值与 t 和 u 相同
  2. 在 B 属性上的取值与 t 相同
  3. 在 R 中不属于 A 和 B 的所有其他属性上的取值与 u 子相同
- MVD A1A2...An →→ B1B2...Bm 指 B 的值与 R 中不在 A 和 B 中的属性是独立的

###### 3.8.2 MVD推导

平凡 MVD：

- A1A2...An →→ B1B2...Bm（$\{B_1,B_2,...,B_m\}\subseteq\{A_1,A_2,...,A_m\}$）

传递规则：

- 属性集 A →→ 属性集 B，属性集 B →→ 属性集 C，则属性集 A →→ 属性集 C

不遵循分解和组合规则

新规则：

+ FD 升级 promotion 规则：每个 FD 都是 MVD
+ 互补 complementation 规则：如果$A1A2...An →→ B1B2...Bm$ 是关系 R 中的 MVD，则 R 也满足 $A1A2...An →→ C1C2...Ck$（C 是 R 中除 A 和 B 外的属性集）

+ 附加平凡 MVD：如果关系 R 的所有属性是 ${A1, A2, ..., An, B1, B2, ..., Bm}，则 A1A2...An →→ B1B2...Bm $在 R 上成立

##### 3.9 第四范式

上述，由于MVD会引起一些冗余，可通过分解中使用依赖消除

4NF本质上是BCNF，但用于消除MVD而非FD

###### 3.9.1 定义：

+ 对于每个非平凡 MVD A1A2...An →→ B1B2...Bm，{A1, A2, ..., An} 都是超键

  $4NF \subset BCNF$

###### 3.9.2 分解为4NF

算法：（已知R，其上的FD和MVD集合为$S_0$）

1. R中找出一个4NF违例:$A1A2...An →→ B1B2...Bm$， {A1,A2,...,An} 不是超键（可以是 MVD 也可以是 FD）
2. 将R分解为两部分，一部分是R1（模式是A和B），另一部分是R2（A以及R中不属于A和B的其他属性）
3. 找出在R1和R2上成立的FD和MVD，递归的分解R1和R2

##### 3.10 范式间的联系

| 性质        | 3NF  | BCNF | 4NF  |
| ----------- | ---- | ---- | ---- |
| 消除FD冗余  | 否   | 是   | 是   |
| 消除MVD冗余 | 否   | 否   | 是   |
| 保持FD      | 是   | 否   | 否   |
| 保持MVD     | 否   | 否   | 否   |

#### PS: 1NF 2NF

第一范式 First Normal Form，1NF：每个属性的值是原子值、有键。

第二范式 Second Normal Form，2NF：所有非主属性都被主键函数决定，不能被主键的一部分决定。

> 整理于2022.03.15
>
> 参考[SuperPung](https://www.notion.so/superpung/6c01057bb5c4474d9849b9df8e759bc1)

