<center><h3><font color = "red">
    	操作系统开天辟地
    </font></h3></center>
> 操作系统骗人不打草稿
>
> 写于操作系统总复习时

### <font color = "purple">0. OS概述</font>

+ 冯诺依曼结构五个部分
  + 运算器、控制器、存储器（memory）、输入设备、输出设备

-----

### <font color = "purple">1. 进程</font>



fork和创建新线程是两回事儿，fork直接是来了个分叉，复制了一份资源，新线程只是弄了一个新的线程去执行你想执行的函数而已，会有一个返回值，成功返回0，失败返回错误编码



#### 进程调度

+ 先来先服务 FCFS
+ 短作业优先 SJF：shortest-job-first
  + 非抢占式：不能被打断，让出CPU后才行
  + 抢占式：新进程可以抢占，比较剩余时间（shortest-remaining-time-first）SRF
    + 需要额外记录每个进程已运行时间、剩余时间
  + 可以降低对长作业有利，不利于长作业，会饥饿
+ 最高响应比优先
+ 轮转法 RR
+ 优先级调度
  + 这个地方要设置优先级

#### 竞争

+ <font color = "red">判断和操作有可能被打断！！</font>

+ 信号量semaphore

  + 非记录型信号量，解决忙等待
    + 对应一个整数，非负整数，正整数值表示资源可用个数，0表示没有资源
  + 记录型信号量，用于睡眠与唤醒方式
    + 有一个等待队列，范围是整个整数集，可整可负
    + 初值代表资源总数
    + 0表示没有等待进程，且资源不可用
    + 有进程在等待该资源，绝对值表示进程个数
  + 二元信号量：
    + 与锁不同，锁是1表示上锁，0表示可用
    + 二元信号量：1表示可用，0表示被占（因为信号量是表示资源数，锁表示有无锁）
  + P原语是去检查有无可用的资源并使用（使用通行证），V是去归还资源并且添加（发通行证）
    + P就是down，V就是up
  + 修改值之前一定要加P进行保护
  + 所有的全局变量需要有一个对应的保护的信号量
  + PV必须成对的出现！！！（检查对错的关键）
  + P就是申请资源，V就是释放资源

#### 死锁

+ 自己占用着对方需要的资源
  + 消费者占据缓冲区想要满格子，生产者想获取缓冲区来产生满格子，发生死锁
  + 注：P操作顺序执行不当会引发死锁，V操作顺序不会
+ 原因：
  + 同种资源数量不足
  + 不同资源
  + P顺序不当
+ 四个必要条件：缺一不可
  + 资源互斥使用
  + 占有且等待：部分占有，期待更多
  + 不可抢占：不能抢占别人的资源
  + 循环等待：等待资源的进程之间存在环

##### 解决方法

+ 鸵鸟算法（假设流行病不存在）
+ 检测恢复（发现了病解决）
+ 避免（开窗通风避免）（躲着）
  + 已经执行，避免
+ 预防（打疫苗）（提前做好准备）
  + 保证某个条件不存在，开始执行之前
  + 破坏四个必要条件
  + 破坏互斥：
    + 解决不了，但比如打印机，都放到一个打印队列里也可
  + 破坏占有且等待：使其全部拥有，一次申请全部的资源，但这个方法不好
    + 不知道需要什么资源
  + 破坏不可抢占：抢过资源（其实往往把进程杀死了）
  + 破坏循环等待：有序分配，把资源进行编号，申请时按资源编号递增次序进行，
    + 有序分配属于破坏循环等待，属于预防

  

-----

### <font color = " purple">2. 内存</font>

#### 2.0 内存管理基础

#### 2.1 分区管理

(不是虚拟内存管理方法)

固定分区：

+ 固定分区：开机时已经把空间分好
  + 一个分区里只能放一个进程，浪费的空间叫内部碎片
+ 每个分区排一个队列或者都排一个队列
+ 采用最佳适应：Best fit
  + 选能放下的，最小的空间，避免浪费。
+ first fit ：FF
  + 每次从头开始找起，第一个能适应的
+ next fit：NF
  + 从上一次找到的，下一个继续去找

可变分区：

+ 可变分区：进程摞着放
  + 不断地用，不断地释放，没有在开机时划好分区
+ 进程之间放不下其他进程，这叫做外部碎片
  + 内碎片其他进程绝对用不了
  + 外碎片其他进程还可以用
+ 内存紧缩：compacting，非常耗时，通常不会用
+ 采用最坏适应：worst fit
  + 找最大的空间去放，剩下的空间大，有可能会被再次使用
+ 不一定就是WF好，也有可能是BF好

表示内存是否占用：

+ 位矢图 Bitmaps
  + 连续的1和0表示是否被占
+ 用链表表示，P表示占用，从几开始连续几个块被占用，H表示空闲，从几开始连续几个块可用



overlaying 覆盖技术：由程序员自己完成，自己进行调用，主程序分成多个子程序，用哪个调哪个

swappping 交换技术：（操作系统的做法）

+ 这两个的区别在于：程序员知道不知道
+ 覆盖是程序员自己干的
  + 不透明，程序员看得见
+ 交换是操作系统干的，把一个阻塞态的进程从内存中搬出，调入一个ready的，然后再换回来，位置可能会变
  + 透明，程序员看不见

#### 2.2 分页管理

分区管理只能放下尽可能多的进程，放不下尽可能大的进程！！！！（分区不能分开）

核心思想：不连续存放

+ 把物理内存划成大小一致的块（内存块，内存帧），再把逻辑地址空间划成页（和块大小一样）
  + 页是一个和块差不多的东西，逻辑空间里叫做页，是一个存储进程的基本单位
  + 页表项是页表里的东西，页表项组成了页表，每个页都要对应着页表里的一个页表项
    + 其实就是通过页表项，实现了页（虚拟地址）和块（内存块，页帧号，物理内存）的对应
+ 有一个页表
  + 页表项的组成
    + 这个页（数组下标）所对应的物理地址的基地址（物理地址空间）以及描述这个页的标志位
  + 这个页，所对应的，页帧号（块号）
  + **页表中，页号（虚拟地址高位）是下标，内容是页帧号**
  + 逻辑地址和物理地址的对应（页和块的对应）
  + 页号（虚拟）和页帧号（物理）没有任何关系
    + 只是简单的一个对应关系而已
+ 逻辑地址 == 页号 + 页内偏移（页的大小）
+ 有可能会有内碎片，因为不能用半个块
+ TLB：translation lookaside buffers 快表
  + 放在cache里，只能放几个页表项，用哪个放哪个
  + 有效位表示：该页在不在内存里
    + 如果是0表示该页不在内存，即缺页，需要去硬盘找
  + 引用位，这是为了配合LRU算法
  + 脏位：是否被修改过。
  + <font color =  "red"> **_特别注意TLB初始时是否为空_**</font>

##### 2.2.1多级页表

+ 页表也要放在页里面，一个页要对应一个页表项，页表项放在页表里
+ 计算时，一定要记得有一级页表

##### 2.2.2 倒置页表

+ 记录物理内存分给了谁
+ 全系统只有一张，大小可以预期

##### 2.2.3 页面置换算法

<font color = "red">**刚来的那几个页，都是缺页中断**</font>

解决空闲空间很小，需要把页面扔出去，换到外存上

+ OPT optimal page replacement：最优页面置换
  + 每次扔再也不用的页面
  + 最好的算法！
  + 不可能实现
+ NRU not recently used
  + R位：被用过，referenced，R位会定期清零，一定时间内被用过
  + M位：是不是脏的，算出来的，或者发生变换，是的话为1
  + 最优选择是R位0，M位0
    + 最近没用过（R为0），很干净（M为0， 没有修改过，可以扔。）
+ FIFO Page Replacement
  + 先进来的先被扔出去
    + 区别在于，最近有没有用过
  + 来的最早最没用
  + 这是一个极差的反面教材！

+ Second Chance Algorithm
  + 增添一个R位（最近有没有用过）
  + 给它第二次机会，看最近有没有用过
  + 放到队尾，并把到达时间清零
  + 是对FIFO算法极大的改进
+ The Clock Page Replacement Algorithm
  + 用指针，每次拨一格，也是看R位
  + 和second chance一模一样，但是画成了一个环
+ LRU least recently used（最近最少使用）（比较好，很难实现）
  + 最近一段时间内用的最少
  + 两个维度：最近，最少
  + 通过矩阵模拟实现
    + 用这个页时，所在的行置1，所在的列清零
    + 置换时，挑所在行0最多，（1最少）的那个进行置换
    + 1的数目表示其重要程度
+ 老化算法：（非常好）
  + 对LRU的近似实现
  + 只能记录最近8个时间滴答
  + 不能无限精确
  + 比较的时候是比较Clock Tick组成的这个二进制数哪个更大



+ Belady异常
  + 页框越多，缺页中断越多：FIFO



<center>
    内存05，一小时时会有例题
</center>



读取时：先快表，再页表（在内存里），再去内存读数据

#### 2.3 分段管理

+ 逻辑地址空间划成逻辑上相关联的单元，每个段以段为单位进内存、出内存
+ 段要考虑逻辑关系
+ 分段好处
  + 整体进内存、整体出内存
  + 段比页大得多
  + 一个进程拆成若干个段，段是比进程小一点的单位，段内连续
  + 分段和可变分区有相同的问题：会有外碎片
  + 和分区不同
    + 分区是整个进程进内存，不是虚拟内存，需要多大空间给多大的空间
    + 分段也可以在较小空间内放下巨大的进程，仍然是虚拟内存管理
  + 分段式管理逻辑地址：由两部分组成
    + 第一部分：段号
    + 第二部分：段内偏移
    + 有段表项
      + base和limit
    + 段表要比页表小得多
  + 分段和overlay
    + 相似：都要分段，用哪个段进哪个段
    + 不同：程序员是否透明
+ 分段坏处：
  + 不好找地方
  + 有外碎片

#### 2.4 分段页

+ 一个段整体的进出内存，但进入内存后可以不连续存放，避免了抖动
+ 需要每个段都有一个页表，既有页表又有段表
+ 段表记录这个段的那张页表在哪里（因为反正也不连续）
  + 记的是段的页表起始地址（物理地址）
+ 段号 + 段内逻辑地址
  + 段内逻辑地址：页号 + 页内逻辑偏移
+ 哪个段的，段里的第几页，页内偏移量多大

#### 2.5 一些简答

+ 为什么老化算法是一种简单有效的算法却只是LRU的近似实现？

  > 老化算法只有有限位的存储，记录最近一段时间内的若干页面的使用情况，无法记录更久远的时间前的使用情况，此外，老化算法无法记录一个时间滴答内的页面的使用频率和使用时间，因此只是LRU的一个近似实现

+ 

-----

### <font color = " purple">3. 存储</font>

#### 3.1 硬盘

+ n个盘片，2n个读写头，一直在转
+ 平均找扇区的时间：磁盘转一圈的时间/2
+ 文件数据块组织方式
  + 连续
  + 链式
  + 多级索引结构
    + 找到inode后，找到所有数据
    + 指针！！！有一半放的指针
+ 文件系统
  + superblock
    + 核心数据
    + 最后一次使用时间
    + 块大小
    + 指向空闲块
      + 因为块不连续，所有的空闲块们串成了一个链
    + 指向空闲inode
    + 指向根文件系统
      + 这个很重要！！！
  + inodes
  + data blocks
  + indirect block指针块

#### 3.2 磁盘臂调度算法

盘片旋转：速度恒定，寻道时间，读取时间，

+ FCFS先来先服务
+ SSTF最短寻短时间优先 shortest seeking time first
  + 最近的那个先去
+ SCAN算法，电梯算法
  + 先沿着一个方向一直走，走到再无请求，调头
  + 不改进的：走到头再掉头----SCAN叫做不改进的
  + 改进的，走到最后一个请求那个地方就掉头----LOOK叫做改进的
  + 天大期末考试如是规定
+ C-SCAN：circle scan
  + 只在往一个方向运动时才会响应请求
  + 好处是公平：SCAN算法中间的访问太快了
  + 同样的有C-LOOK
    + cscan是没优化过的，一口气走到头

#### 3.3硬盘

+ 硬盘当作一个容器，去放文件系统
+ 一个U盘可以整体作为文件系统的容器
+ 硬盘比较大，逻辑分区？
  + 最多四个主分区，但其中一个主分区可以变成扩展分区
    + 主分区从1开始，1 2 3 4
  + 扩展分区里可以有无限逻辑分区，逻辑分区从5开始
    + 装分区的分区
  + 一个分区里一个文件系统，一个文件系统放在一个分区
+ 文件系统大小可以不等于容器大小，这是两个东西
+ 分区的话会有很多缺点，容量不可扩，不可缩
  + 分区大小固定，且要求连续



+ 逻辑卷管理：分块，分页存放
  + 起了个名：物理卷，其实就是物理硬盘
  + 多个物理硬盘组成卷组，卷组横跨物理硬盘，是我们接触到的最大的存储单元
  + 分成若干个大小相同的块：物理块，物理块可以不连续，做成一个逻辑卷
    + 逻辑卷由若干个物理块组成，可以不连续，甚至跨硬盘，再逻辑卷上创建文件系统
  + 同样的需要有一张表来管理
  + 逻辑卷很容易扩，但不好缩
+ 硬盘怎么备份？两个方法
  + 备份：特定时间，把它做一个存储，不再随文件而改动，快照
  + 镜像：同时存两份，两份永远保持一致
+ 需要提高数据的安全性---镜像
  + 备份需要换一个介质存放
  + 镜像是存放的时候把它存在两个硬盘上，一个逻辑块占两个物理块

#### 3.4 RAID

+ Redundant Array of Independent Disk 廉价磁盘冗余阵列
  + 一个纯硬件的东西
  + 使硬盘：高可靠，高可用
    + 高可靠：数据不丢
    + 高可用：更快
  + 硬件技术！有些RAID提高高可靠，有些是高可用
+ JBOD：只是一堆硬盘
  + 放满了第一个放第二个····
  + 不高可靠，不高可用，就是一堆硬盘
+ RAID 0
  + 数据交替放，没有提高可靠性，第一个放一号硬盘，第二个放二号硬盘，
  + 提高了可用性，更快了
  + 容量不损失
  + 两块（多块）硬盘一起写，一起读，自然而然更快了
+ RAID 1
  + 镜像，通过芯片，写两份
  + 速度没有提升，但是高可靠了，坏任何一个硬盘，数据不丢
  + 空间容量缩了50%
+ RAID 10（先1再0）
  + 最少四块硬盘，先做镜像，然后另一边是采用RAID0
  + 10比01要好，先1后0
  + 高可靠，高可用，只是浪费了一半的空间
+ RAID 5
  + 四块硬盘，第四块是放前三个的校验（奇偶校验）
    + 其实也不能这么说，校验是分开的，每个盘都有校验块
  + 利用率：` (n-1)/n` 
  + 贵
  + 其实至少需要3块硬盘即可。



------

### 4. 设备管理

+ 操作系统里，设备不包括CPU和内存
+ 内核
  + 微内核：越小越好
  + 宏内核：越大越好



+ 怎么找到设备？
  + 找内存是线性编址
  + 独立的给IO 端口编号，为所有的IO设备编写独立的读写指令
  + 所有的设备端口和内存统一编址，地址挨着
    + 前一段内存，中间一段设备
    + 用同一格式编写端口
    + 不需要独立的编写指令
  + 混合式，一部分联合在一起编址，一部分独立编址
    + 长得像内存的联合编址----如：显卡
+ 怎么通信？Bus 总线
  + 只能两两传数据
+ DMA：CPU让DMA去控制高速设备传输数据，如磁盘



+ block devices 块设备
  + 允许随机访问（定义）
  + 如硬盘
  + 大容量，一块儿一块儿的读，即使读一个字节也是按块
  + 所以DMA用于块设备，而不是字符设备
+ 字符设备
  + 低速，小
  + 不能随机访问（定义）